(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{608:function(v,_,t){"use strict";t.r(_);var r=t(12),e=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("table",[t("thead",[t("tr",[t("th"),v._v(" "),t("th",[v._v("时间复杂度")]),v._v(" "),t("th",[v._v("空间复杂度")]),v._v(" "),t("th",[v._v("原地")]),v._v(" "),t("th",[v._v("稳定")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("冒泡")]),v._v(" "),t("td",[v._v("O(n²)")]),v._v(" "),t("td",[v._v("O(1)")]),v._v(" "),t("td",[v._v("原地")]),v._v(" "),t("td",[v._v("稳定")])]),v._v(" "),t("tr",[t("td",[v._v("插入")]),v._v(" "),t("td",[v._v("O(n²)")]),v._v(" "),t("td",[v._v("O(1)")]),v._v(" "),t("td",[v._v("原地")]),v._v(" "),t("td",[v._v("稳定")])]),v._v(" "),t("tr",[t("td",[v._v("选择")]),v._v(" "),t("td",[v._v("O(n²)")]),v._v(" "),t("td",[v._v("O(1)")]),v._v(" "),t("td",[v._v("原地")]),v._v(" "),t("td",[t("code",[v._v("不稳定")])])]),v._v(" "),t("tr",[t("td",[v._v("归并")]),v._v(" "),t("td",[v._v("O(nlogn)")]),v._v(" "),t("td",[v._v("O(n)")]),v._v(" "),t("td",[v._v("不是")]),v._v(" "),t("td",[v._v("稳定")])]),v._v(" "),t("tr",[t("td",[v._v("快速")]),v._v(" "),t("td",[v._v("O(nlogn)")]),v._v(" "),t("td",[v._v("O(1)")]),v._v(" "),t("td",[v._v("原地")]),v._v(" "),t("td",[t("code",[v._v("不稳定")])])]),v._v(" "),t("tr",[t("td",[v._v("计数")]),v._v(" "),t("td",[v._v("O(n)")]),v._v(" "),t("td"),v._v(" "),t("td"),v._v(" "),t("td")]),v._v(" "),t("tr",[t("td",[v._v("桶")]),v._v(" "),t("td",[v._v("O(n)")]),v._v(" "),t("td"),v._v(" "),t("td"),v._v(" "),t("td")]),v._v(" "),t("tr",[t("td",[v._v("基数")]),v._v(" "),t("td",[v._v("O(n)")]),v._v(" "),t("td"),v._v(" "),t("td"),v._v(" "),t("td")])])]),v._v(" "),t("h1",{attrs:{id:"思考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#思考"}},[v._v("#")]),v._v(" 思考")]),v._v(" "),t("p",[v._v("为什么插入排序比冒泡排序更受欢迎?")]),v._v(" "),t("blockquote",[t("p",[v._v("冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个")])]),v._v(" "),t("p",[v._v("当需要对性能要求做到极致，插入排序算法还可以继续优化，可参考: 希尔排序")]),v._v(" "),t("h1",{attrs:{id:"插入排序-insertion-sort"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#插入排序-insertion-sort"}},[v._v("#")]),v._v(" 插入排序（Insertion Sort）")]),v._v(" "),t("p",[v._v("名字：（选择一个元素）插入到合适的位置，终点"),t("code",[v._v("找到合适的位置插入")])]),v._v(" "),t("p",[v._v("思想：分"),t("strong",[v._v("已排序区间")]),v._v("和"),t("strong",[v._v("未排序区间")]),v._v("，初始数组的第一个元素为已排序区间，\n取未排序区间中的元素，在已排序区间中找到合适的位置插入。重复这一过程\n直到未排序区间中元素为空。")]),v._v(" "),t("p",[v._v("操作：")]),v._v(" "),t("ol",[t("li",[v._v("比较")]),v._v(" "),t("li",[v._v("移动插入")])]),v._v(" "),t("h2",{attrs:{id:"希尔排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#希尔排序"}},[v._v("#")]),v._v(" 希尔排序")]),v._v(" "),t("p",[v._v("是插入排序的一种更高效的改进版本，是一种不稳定的排序算法")]),v._v(" "),t("h1",{attrs:{id:"选择排序-selection-sort"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#选择排序-selection-sort"}},[v._v("#")]),v._v(" 选择排序（Selection Sort）")]),v._v(" "),t("p",[v._v("名字："),t("code",[v._v("选择最小的元素")]),v._v("（插入到末尾），终点是选择")]),v._v(" "),t("p",[v._v("思想：类似插入排序，分"),t("strong",[v._v("已排序区间")]),v._v("和"),t("strong",[v._v("未排序区间")]),v._v("，初始已排序区间为空，\n每次从未排序区间中找到"),t("strong",[v._v("最小的元素")]),v._v("，将其放入到已排序区间末尾（与末尾元素交换）。")]),v._v(" "),t("p",[v._v("不稳定：")]),v._v(" "),t("blockquote",[t("p",[v._v("5，8，5，2，9 使用选择排序算法来排序，第一次找到最小元素 2，\n与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了")])]),v._v(" "),t("h1",{attrs:{id:"归并排序-merge-sort"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#归并排序-merge-sort"}},[v._v("#")]),v._v(" 归并排序（Merge Sort）")]),v._v(" "),t("p",[v._v("思想：将数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分\n合并在一起。当分别排序分解到一个元素时，开始合并。")]),v._v(" "),t("p",[v._v("核心：合并函数 merge()")]),v._v(" "),t("p",[t("img",{attrs:{src:"images/2022-01-23-16-46-50.png",alt:""}})]),v._v(" "),t("h1",{attrs:{id:"快速排序-quicksort"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快速排序-quicksort"}},[v._v("#")]),v._v(" 快速排序（Quicksort）")]),v._v(" "),t("p",[v._v("思想：")]),v._v(" "),t("ol",[t("li",[v._v("找到一个分区点（pivot），将大于分区点的放在右边，将小于分区点的放在左边。")]),v._v(" "),t("li",[v._v("根据分治递归思想，将分区点的左右两部分重复第一步操作，直到区间缩小为1")])]),v._v(" "),t("p",[v._v("核心：分区函数 partition()")]),v._v(" "),t("p",[t("img",{attrs:{src:"images/2022-01-23-17-12-43.png",alt:""}}),v._v("\n使用技巧实现，原地排序")]),v._v(" "),t("ol",[t("li",[v._v("i,j两个指针，i指向一个大于分区点pivot的数(此时，i的左侧是小于pivot的数，\ni的右侧~j的左侧是大于pivot的数，j右侧待扫描)")]),v._v(" "),t("li",[v._v("j一直扫描寻找小于pivot的数，找到与i指向的数交换，此时，i向右移动一位，\nj继续扫描。")]),v._v(" "),t("li",[v._v("重复上述操作，直到j指向最后一个数（以最后一个数为pivot）\n数组插入元素技巧：")])]),v._v(" "),t("p",[v._v("技巧：在 O(1) 的时间复杂度内完成数组插入操作")]),v._v(" "),t("p",[v._v("前提：如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。")]),v._v(" "),t("p",[v._v("优点：避免大规模的数据搬移")]),v._v(" "),t("p",[v._v("实现方式：直接将第 k 位的数据搬移到数组元素的最后，\n把新的元素直接放入第 k 个位置。")]),v._v(" "),t("h3",{attrs:{id:"不稳定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不稳定"}},[v._v("#")]),v._v(" 不稳定")]),v._v(" "),t("blockquote",[t("p",[v._v("分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列 "),t("code",[v._v("6，8，7，6，3，5，9，4")]),v._v(",\n在经过第一次分区操作之后，两个 6 的相对先后顺序就会改变。所以，快速排序是"),t("code",[v._v("不稳定")]),v._v("的排序算法。")])]),v._v(" "),t("p",[v._v("参考")]),v._v(" "),t("p",[t("a",{attrs:{href:"https://time.geekbang.org/column/article/41802",target:"_blank",rel:"noopener noreferrer"}},[v._v("11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？"),t("OutboundLink")],1)]),v._v(" "),t("p",[t("a",{attrs:{href:"https://time.geekbang.org/column/article/41913",target:"_blank",rel:"noopener noreferrer"}},[v._v("12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？"),t("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=e.exports}}]);