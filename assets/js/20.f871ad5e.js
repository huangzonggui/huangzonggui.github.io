(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{549:function(t,a,n){t.exports=n.p+"assets/img/2023-03-31-16-06-28.c02d3f05.png"},550:function(t,a,n){t.exports=n.p+"assets/img/2023-04-08-15-37-03.b8b6358b.png"},621:function(t,a,n){"use strict";n.r(a);var r=n(12),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"pnpm-yarn-npm-包管理工具区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#pnpm-yarn-npm-包管理工具区别"}},[t._v("#")]),t._v(" pnpm yarn npm 包管理工具区别")]),t._v(" "),r("h2",{attrs:{id:"npm-问题-嵌套结构树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#npm-问题-嵌套结构树"}},[t._v("#")]),t._v(" npm 问题（嵌套结构树）")]),t._v(" "),r("ul",[r("li",[t._v("包占用空间大")]),t._v(" "),r("li",[t._v("嵌套引用时，包会重复安装")])]),t._v(" "),r("h3",{attrs:{id:"npm-改进-flat-结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#npm-改进-flat-结构"}},[t._v("#")]),t._v(" npm 改进（flat 结构）")]),t._v(" "),r("ul",[r("li",[t._v("npm@2 之后，包的安装方式变成了 flat 的，也就是说，所有的包都会安装在 node_modules 的根目录下，这样会导致包的重复安装")])]),t._v(" "),r("h2",{attrs:{id:"yarn-flat-结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#yarn-flat-结构"}},[t._v("#")]),t._v(" yarn（flat 结构）")]),t._v(" "),r("p",[t._v("为避免包的重复安装")]),t._v(" "),r("ul",[r("li",[t._v("yarn 使用 flat 的方式来安装包，但是它会在安装包的时候，会把包的依赖也安装到根目录下，这样就避免了包的重复安装")])]),t._v(" "),r("p",[t._v("npm@2 之后 和 yarn 都是使用 flat 的方式来安装包，但是当项目没有依赖某个包，\n但是某个依赖包依赖了这个包，这样就将该包安装到了根目录下，\n项目如果使用这个包，当依赖包不再依赖这个包时，这个包就会被删除，\n包会被删除，从而导致项目无法运行")]),t._v(" "),r("h3",{attrs:{id:"flat-方式带来的问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#flat-方式带来的问题"}},[t._v("#")]),t._v(" flat 方式带来的问题：")]),t._v(" "),r("ul",[r("li",[t._v("幽魂依赖：项目中的包被删除，但是项目还在使用这个包，这样就会导致项目无法运行")])]),t._v(" "),r("h2",{attrs:{id:"pnpm"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#pnpm"}},[t._v("#")]),t._v(" pnpm")]),t._v(" "),r("h3",{attrs:{id:"pnpm-链接方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#pnpm-链接方式"}},[t._v("#")]),t._v(" "),r("code",[t._v("pnpm")]),t._v(" 链接方式：")]),t._v(" "),r("ul",[r("li",[t._v("使用软链接的方式表示包之间的依赖关系")]),t._v(" "),r("li",[t._v("使用硬链接的方式，链接到全局的 "),r("code",[t._v("store")]),t._v(" 中，减少包的重复")])]),t._v(" "),r("blockquote",[r("p",[t._v("硬链接：在同一个文件系统中，多个文件名指向同一个文件内容，这种文件名的关系称为硬链接。硬链接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要文件，以防止“误删”的功能。硬链接的一个缺点是，不能跨文件系统，即硬链接只有在同一个文件系统中才能创建成功。\n删除硬链接文件不影响原文件，只有当原文件的所有硬链接文件都被删除后，原文件才会被删除。\n硬链接图解：\n"),r("img",{attrs:{src:n(549),alt:""}})])]),t._v(" "),r("p",[r("img",{attrs:{src:n(550),alt:""}}),t._v("\n图片来源："),r("a",{attrs:{href:"https://dev.to/atian25/in-depth-of-tnpm-rapid-mode-how-could-we-fast-10s-than-pnpm-3bpp",target:"_blank",rel:"noopener noreferrer"}},[t._v("In-depth of tnpm rapid mode - how we managed to be 10 second faster than pnpm"),r("OutboundLink")],1)]),t._v(" "),r("h3",{attrs:{id:"对比-npm-和-yarn-的优势"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对比-npm-和-yarn-的优势"}},[t._v("#")]),t._v(" 对比 npm 和 yarn 的优势")]),t._v(" "),r("ul",[r("li",[t._v("不依赖 "),r("code",[t._v("Node.js")]),t._v(" 的 "),r("code",[t._v("Runtime")]),t._v("，直接安装 "),r("code",[t._v("brew install pnpm")])]),t._v(" "),r("li",[t._v("通过 "),r("code",[t._v("pnpm")]),t._v(" 命令，可以管理 "),r("code",[t._v("Node.js")]),t._v(" 版本，代替 "),r("code",[t._v("nvm")])])]),t._v(" "),r("p",[t._v("所以可以用 "),r("code",[t._v("pnpm")]),t._v(" 来代替 "),r("code",[t._v("yarn")]),t._v(" 、 "),r("code",[t._v("npm")]),t._v(" 和 "),r("code",[t._v("nvm")])]),t._v(" "),r("h2",{attrs:{id:"参考"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://juejin.cn/post/7158631927992287263",target:"_blank",rel:"noopener noreferrer"}},[t._v("pnpm 原理解析"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=e.exports}}]);